## rust与cpp赋值对比v2
| 特性                  | Rust                                               | C++                                                |
|-----------------------|----------------------------------------------------|---------------------------------------------------|
| **move 语义**          | 所有权转移，原变量不可再访问，堆变量由 Rust 自动管理（回收） | 无所有权转移，原变量在原作用域可再访问，栈字段和堆变量的复制只涉及栈字段赋值  |
| **copy 语义**          | 栈变量的简单复制(按位（bitwise）复制)，直接复制数据，所有权不转移(创建新owner)       | 默认浅拷贝，复制栈字段，不涉及堆内存内容（如果有指针则复制指针，浅拷贝）(cpp中，move和copy语义是一样的)  |
| **clone 语义**         | 创建新的堆变量，进行深拷贝，堆内存由 Rust 自动管理（回收），语法上需要显式调用，如x.clone() | 手动实现深拷贝，通常通过拷贝构造函数来实现，堆内存需要手动管理（new\delete操作）,语法上采用赋值语句触发（=） |
| **堆内存管理**         | 自动释放堆内存（由所有权机制管理）               | 手动释放堆内存，容易出现内存泄漏或野指针问题     |
| **野指针处理**         | 不存在野指针，Rust 会确保没有悬空引用              | 需要手动管理，容易出现悬空引用或野指针           |
| **拷贝构造函数**       | 没有，复制结构体时会根据语义自动处理（move/copy/clone）| 如果需要深拷贝，必须手动实现拷贝构造函数           |



参考：
Rust 中级教程 第11课——所有权与trait（4）

https://zhuanlan.zhihu.com/p/661956588

摘：
关于性能：我们可以通过 clone 方法，来实现深复制，将深复制后的数据传递到函数体内，而原有的变量则不会失去所有权。这样的做法并不推荐，会损耗性能。

TODO
补充借用机制